networks:
  proxy-net:
    external: true
  postgres-net:
    external: true
services:
  drawdb:
    image: xinsodev/drawdb
    # ports:
    #   - 3000:80
    restart: always
    labels:
      traefik.enable: true
      traefik.http.routers.drawdb.rule: Host(`drawdb.home.staniek.name`)
      traefik.http.routers.drawdb.entrypoints: websecure
      traefik.http.routers.drawdb.tls.certresolver: letsencrypt
      traefik.http.services.drawdb.loadbalancer.server.port: 80
      glance.name: DrawDB
      glance.icon: sh:database
      glance.description: "Collaborative Drawing Database"
      glance.url: https://drawdb.home.staniek.name
      glance.id: postgres
    networks:
      - proxy-net
      - postgres-net

  pgbackweb:
    image: eduardolat/pgbackweb:latest
    # ports:
    #   - "8085:8085" # Access the web interface at http://localhost:8085
    volumes:
      # - /opt/docker-data/pgbackweb/backups:/backups # If you only use S3 destinations, you don't need this volume
      - /opt/backup/postgres/database:/backups
    env_file: pgbackweb.env
    environment:
      # Optional environment variables are ignored, see the configuration section below for more details
      PBW_ENCRYPTION_KEY: ${PBW_ENCRYPTION_KEY} # Change this to a strong key
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - proxy-net
      - postgres-net
    labels:
      traefik.enable: true
      traefik.http.routers.pgbackweb.rule: Host(`pgbackup.home.staniek.name`)
      traefik.http.services.pgbackweb.loadbalancer.server.port: 8085
      traefik.http.routers.pgbackweb.entrypoints: websecure
      traefik.http.routers.pgbackweb.tls.certresolver: letsencrypt
      glance.name: PGBackWeb
      glance.icon: sh:database-backup
      glance.description: "PostgreSQL Backup Web Interface"
      glance.url: https://pgbackup.home.staniek.name
      glance.id: postgres
  postgres:
    image: docker.io/postgres:16-alpine
    pull_policy: always
    env_file: postgres.env
    environment:
      - |
        POSTGRES_INIT_SCRIPT=#!/bin/bash

        set -euo pipefail

        # Creates role + database (if missing) and grants privileges.
        # Expected to run inside a Postgres container/init context where:
        #   POSTGRES_USER / POSTGRES_DB are set and psql can connect.

        create_user_and_database() {
          local database="$1"
          local user="$2"
          local password="$3"

          if [[ -z "$$database" || -z "$$user" || -z "$$password" ]]; then
            echo "ERROR: create_user_and_database requires: <db> <user> <password>" >&2
            return 1
          fi

          echo "==> Ensuring role '$$user' and database '$$database' exist"

          # 1) Create role if missing
          psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" --dbname "$$POSTGRES_DB" \
            -v usr="$$user" -v pwd="$$password" <<'EOSQL'
        SELECT format('CREATE ROLE %I LOGIN PASSWORD %L', :'usr', :'pwd')
        WHERE NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'usr');
        \gexec
        EOSQL

          # 2) Create database if missing (CREATE DATABASE can't run inside a DO/transaction)
          psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" --dbname "$$POSTGRES_DB" \
            -v db="$$database" -v usr="$$user" <<'EOSQL'
        SELECT format('CREATE DATABASE %I OWNER %I', :'db', :'usr')
        WHERE NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = :'db')
        \gexec
        EOSQL

          # 3) Grant privileges (idempotent)
          psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" --dbname "$$POSTGRES_DB" \
            -v db="$$database" -v usr="$$user" <<'EOSQL'
        GRANT ALL PRIVILEGES ON DATABASE :"db" TO :"usr";
        EOSQL
        }

        services="$${POSTGRES_INIT_SERVICES:-}"
        if [[ -z "$$services" ]]; then
          echo "ERROR: POSTGRES_INIT_SERVICES is empty (expected e.g. 'PGBACKWEB NETBOX DIODE HYDRA')" >&2
          exit 1
        fi

        for s in $$services; do
          db_var="$${s}_POSTGRES_DB_NAME"
          user_var="$${s}_POSTGRES_USER"
          pass_var="$${s}_POSTGRES_PASSWORD"
          echo "Preparing database for $$s..."
          create_user_and_database "$${!db_var}" "$${!user_var}" "$${!pass_var}"
        done
        echo "PostgreSQL initialization script completed."

    command: |
      sh -c "
        echo \"$$POSTGRES_INIT_SCRIPT\" > /docker-entrypoint-initdb.d/01-init-databases.sh && \
        chmod +x /docker-entrypoint-initdb.d/01-init-databases.sh && \
        docker-entrypoint.sh postgres
      "
    ports: []
    healthcheck:
      test: ["CMD-SHELL", "sh -c 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}'"]
      start_period: 20s
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - type: tmpfs
        target: /docker-entrypoint-initdb.d
        tmpfs:
          size: 1048576  # 1MB
    networks:
      - postgres-net

    labels:
      glance.name: Postgres Database
      glance.description: PostgreSQL Database Server
      glance.icon: sh:postgresql
      glance.parent: postgres

volumes:
  postgres-data: