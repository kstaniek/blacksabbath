networks:
  proxy-net:
    external: true
  netbox-net:
    external: true

volumes:
  database-data:
    driver: local
  redis-data:
    driver: local
  netbox-media:
    driver: local
  netbox-reports:
    driver: local
  netbox-scripts:
    driver: local

services:
  redis:
    image: redis:7-alpine
    pull_policy: always
    env_file: redis.env
    command:
      - sh
      - -c
      - redis-server --appendonly yes --requirepass $$REDIS_PASSWORD
    healthcheck: &redis-healthcheck
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 10
    ports: []
    restart: unless-stopped
    networks:
      - netbox-net
    labels:
      glance.name: Redis
      glance.parent: netbox
  redis-cache:
    image: redis:7-alpine
    pull_policy: always
    env_file: redis-cache.env
    command:
      - sh
      - -c
      - redis-server --appendonly yes --dir /data --save 60 1 --requirepass $$REDIS_PASSWORD
    healthcheck: *redis-healthcheck
    ports: []
    restart: unless-stopped
    volumes:
      - redis-data:/data
    networks:
      - netbox-net
    labels:
      glance.name: Redis Cache
      glance.parent: netbox
    
  database:
    image: docker.io/postgres:16-alpine
    pull_policy: always
    env_file: database.env
    environment:
      - |
        POSTGRES_INIT_SCRIPT=#!/bin/bash

        set -euo pipefail

        # Create databases and users with privileges for each service

        psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" --dbname "$$POSTGRES_DB" <<-EOSQL
            -- Netbox
            CREATE USER $${NETBOX_POSTGRES_USER} WITH PASSWORD '$${NETBOX_POSTGRES_PASSWORD}';
            CREATE DATABASE $${NETBOX_POSTGRES_DB_NAME} OWNER $${NETBOX_POSTGRES_USER};
            GRANT ALL PRIVILEGES ON DATABASE $${NETBOX_POSTGRES_DB_NAME} TO $${NETBOX_POSTGRES_USER};

            -- Diode
            CREATE USER $${DIODE_POSTGRES_USER} WITH PASSWORD '$${DIODE_POSTGRES_PASSWORD}';
            CREATE DATABASE $${DIODE_POSTGRES_DB_NAME} OWNER $${DIODE_POSTGRES_USER};
            GRANT ALL PRIVILEGES ON DATABASE $${DIODE_POSTGRES_DB_NAME} TO $${DIODE_POSTGRES_USER};

            -- Hydra
            CREATE USER $${HYDRA_POSTGRES_USER} WITH PASSWORD '$${HYDRA_POSTGRES_PASSWORD}';
            CREATE DATABASE $${HYDRA_POSTGRES_DB_NAME} OWNER $${HYDRA_POSTGRES_USER};
            GRANT ALL PRIVILEGES ON DATABASE $${HYDRA_POSTGRES_DB_NAME} TO $${HYDRA_POSTGRES_USER};
        EOSQL
    command: |
      sh -c "
        echo \"$$POSTGRES_INIT_SCRIPT\" > /docker-entrypoint-initdb.d/01-init-databases.sh && \
        chmod +x /docker-entrypoint-initdb.d/01-init-databases.sh && \
        docker-entrypoint.sh postgres
      "
    ports: []
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${NETBOX_POSTGRES_USER} -d ${NETBOX_POSTGRES_DB_NAME}"]
      start_period: 20s
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    volumes:
      - database-data:/var/lib/postgresql/data
      - type: tmpfs
        target: /docker-entrypoint-initdb.d
        tmpfs:
          size: 1048576  # 1MB
    networks:
      - netbox-net
    labels:
      glance.name: Postgres
      glance.parent: netbox

  netbox:
    build:
      context: .
      dockerfile: Dockerfile-netbox-plugins
      pull: true
    image: netbox-with-plugins:v4.4.8
    pull_policy: never
    healthcheck:
      test: curl -f http://localhost:8080/login/ || exit 1
      # first time migration can take a while
      start_period: 10m
      timeout: 3s
      interval: 15s
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_healthy
      redis-cache:
        condition: service_healthy
    env_file: netbox.env
    configs:
      - source: plugins-config
        target: /etc/netbox/config/plugins.py
    networks:
      - proxy-net
      - netbox-net
    volumes:
      - netbox-media:/opt/netbox/netbox/media
      - netbox-reports:/opt/netbox/netbox/reports
      - netbox-scripts:/opt/netbox/netbox/scripts
    restart: unless-stopped
    labels:
      traefik.enable: true
      traefik.http.routers.netbox.rule: Host(`netbox.home.staniek.name`)
      traefik.http.routers.netbox.entrypoints: websecure
      traefik.http.routers.netbox.tls.certresolver: letsencrypt
      traefik.http.services.netbox.loadbalancer.server.port: 8080
      glance.name: NetBox
      glance.icon: sh:netbox
      glance.url: https://netbox.home.staniek.name
      glance.description: "NetBox infra documentation"
      glance.id: netbox
      
  netbox-worker:
    image: netbox-with-plugins:v4.4.8
    depends_on:
      netbox:
        condition: service_healthy
    env_file: netbox.env
    configs:
      - source: plugins-config
        target: /etc/netbox/config/plugins.py
    networks:
      - netbox-net
    command: ["python", "/opt/netbox/netbox/manage.py", "rqworker"]
    restart: unless-stopped
    healthcheck:
      test: ps -aux | grep -v grep | grep -q rqworker || exit 1
      start_period: 20s
      timeout: 3s
      interval: 15s
    labels:
      glance.name: NetBox Worker
      glance.parent: netbox

  ingress-nginx:
    image: nginx:latest
    pull_policy: always
    command: nginx -g 'daemon off;'
    restart: on-failure
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:z,ro
    depends_on:
      - diode-auth
      - diode-ingester
      - diode-reconciler
    networks:
      - netbox-net
    labels:
      glance.name: Ingress NGINX
      glance.parent: netbox

  diode-ingester:
    image: netboxlabs/diode-ingester:${DIODE_TAG:-latest}
    pull_policy: always
    env_file: diode-ingester.env
    restart: on-failure
    ports: []
    depends_on:
      redis:
        condition: service_healthy
      diode-reconciler:
        condition: service_started
    networks:
      - netbox-net
    labels:
      glance.name: Diode Ingester
      glance.parent: netbox

  diode-reconciler:
    image: netboxlabs/diode-reconciler:${DIODE_TAG:-latest}
    pull_policy: always
    env_file: diode-reconciler.env
    configs:
      - source: client-credentials
        target: /etc/config/oauth2/client/client-credentials.json
    restart: on-failure
    ports: []
    depends_on:
      redis:
        condition: service_healthy
      database:
        condition: service_healthy
      netbox:
        condition: service_healthy
    networks:
      - netbox-net
    labels:
      glance.name: Diode Reconciler
      glance.parent: netbox

  hydra:
    image: oryd/hydra:v25.4.0
    pull_policy: always
    expose:
      - "4444"
      - "4445"
    command: serve all --dev
    env_file: hydra.env
    restart: on-failure
    depends_on:
      database:
        condition: service_healthy
      hydra-migrate:
        condition: service_started
    networks:
      - netbox-net
    labels:
      glance.name: Hydra
      glance.parent: netbox
  
  hydra-migrate:
    image: oryd/hydra:v25.4.0
    pull_policy: always
    command: migrate sql up -e --yes
    env_file: hydra.env
    restart: on-failure
    depends_on:
      database:
        condition: service_healthy
    networks:
      - netbox-net
    labels:
      glance.name: Hydra Migrator
      glance.parent: netbox
    
  diode-auth:
    image: netboxlabs/diode-auth:${DIODE_TAG:-latest}
    pull_policy: always
    env_file: diode-auth.env
    restart: on-failure
    ports: []
    depends_on:
      - hydra
      - diode-auth-bootstrap
    networks:
      - netbox-net
    labels:
      glance.name: Diode Auth
      glance.parent: netbox
    
  diode-auth-bootstrap:
    image: netboxlabs/diode-auth:${DIODE_TAG:-latest}
    pull_policy: always
    command: ["/bin/sh", "/etc/config/oauth2/bootstrap-clients.sh"]
    configs:
      - source: client-credentials
        target: /etc/config/oauth2/client/client-credentials.json
    env_file: diode-auth-bootstrap.env
    restart: on-failure
    depends_on:
      - hydra
    networks:
      - netbox-net
    labels:
      glance.name: Diode Auth Bootstrap
      glance.parent: netbox

  # orb-agent:
  #   image: netboxlabs/orb-agent:latest
  #   restart: unless-stopped
  #   # network_mode: host

  #   command: run --config /config.yaml
  #   volumes:
  #     - ./orb-agent/config.yaml:/config.yaml:ro
  #   networks: [internal]
  #   depends_on:
  #     - diode-ingester
  #     - diode-reconciler
  #   labels:
  #     glance.name: ORB Agent
  #     glance.parent: netbox

configs:
  client-credentials:
    content: |
      [
        {
              "client_id": "diode-ingest",
              "client_secret": "${DIODE_INGEST_SECRET}",
              "grant_types": ["client_credentials"],
              "scope": "diode:ingest"
          },
        {
              "client_id": "netbox-to-diode",
              "client_secret": "${NETBOX_TO_DIODE_CLIENT_SECRET}",
              "grant_types": ["client_credentials"],
              "scope": "diode:read diode:write"
          },
        {
              "client_id": "diode-to-netbox",
              "client_secret": "${DIODE_TO_NETBOX_CLIENT_SECRET}",
              "grant_types": ["client_credentials"],
              "scope": "netbox:read netbox:write"
          }
      ]
  
  plugins-config:
    content: |
      from netbox_branching.utilities import DynamicSchemaDict

      PLUGINS = [
          "netbox_dns",
          "netbox_diode_plugin",
          "netbox_branching",
      ]

      PLUGINS_CONFIG = {
          # "netbox_topology_views": {
          #     "always_save_coordinates": True,
          # },

          # Diode needs config once you actually connect it to a Diode service.
          # See the plugin docs for the required values.
          "netbox_diode_plugin": {
              "diode_target_override": "grpc://ingress-nginx/diode",
              "diode_username": "netbox-to-diode",
              "netbox_to_diode_client_secret": "${NETBOX_TO_DIODE_SECRET}",
          },
      }



      DATABASES = DynamicSchemaDict({
          'default': {
              'ENGINE': 'django.db.backends.postgresql',
              'NAME': 'netbox',                                   # Database name
              'USER': 'netbox',                                   # PostgreSQL username
              'PASSWORD': '${NETBOX_POSTGRES_PASSWORD}',          # PostgreSQL password
              'HOST': 'database',                                 # Database server
              'PORT': '',                                         # Database port (leave blank for default)
              'CONN_MAX_AGE': 300,                                # Max database connection age
          }
      })

      DATABASE_ROUTERS = [
          'netbox_branching.database.BranchAwareRouter',
      ]
